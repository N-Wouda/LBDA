    
    
    
    
    size_t n1, p1, m1, n2, p2, m2, S;            // input size
    /*
    n1 = 2; p1 = 0; m1 = 1; n2 = 3; p2 = 3; m2 = 2 ; S = 1;          // exact ald very slow for n1 > 1
                                                 // parameter bounds (uniform distribution)  
    size_t A_low, A_high, T_low, T_high, W_low, W_high, c_low, c_high, b_low, b_high, q_low, q_high;
    A_low = 1; A_high = 4; T_low = 0; T_high = 2; W_low = 1; W_high = 5; 
    c_low = 2; c_high = 4; b_low = 1, b_high = 5; q_low = 2; q_high = 10;
    
    A_low = 1; A_high = 4; T_low = 1; T_high = 1; W_low = 2; W_high = 2; 
    //c_low = 1; c_high = 1; b_low = 1, b_high = 5; q_low = 1; q_high = 1;
                                                 // create problem
    Problem problem(n1, p1, m1, n2, p2, m2, S, rand, env, 0, m1, 0, m2); 
    */
    
    
    
    
    
    
    
    
    
    
    /*
    problem.randomInstance(A_low, A_high, T_low, T_high, W_low, W_high, c_low, c_high, b_low, b_high, q_low, q_high);
    problem.set_omega_gaus(10.0, 1.0);   
                                                 // set upper and lower bounds 
    //vector<double> l1(n1, 0.0); vector<double> u1(n1, 5.0); vector<double> l2(n2, 0.0); vector<double> u2(n2, 5.0); 
    //problem.set_bounds(l1, u1, l2, u2);
    double *x;  // x contains solutions    
    problem.enforce_ccr(10);
    
    Benders ben(env, c_env, problem);
    
    ben.lpSolve();
    

    
    

    // END TEST
    
    //ben.strong_benders();

    double alpha[m2];
    fill_n(alpha, m2, 0.0);
    //ben.lbda(alpha, 1.0);
    
    double tau_bar = 1;
    //ben.zk_solve(true, tau_bar, 1e-4, 25);
    
    //ben.ald_solve(0.1, 25);
    //ben.ald_affine(0.1, 25);
    x = ben.d_xvals; 
    cout << "x: ";  
    for (size_t var = 0; var != n1; ++var)
      cout << x[var] << ' ';
    cout << '\n';

    cout << "cx + Q(x) = " << problem.evaluate(x) << '\n';
    
          // Solving the DEF  
    DeqForm DEF(env, problem);   
    DEF.d_model.write("test.mps");
    DEF.solve(10.0);
          // printing DEF solution and objective
    x = DEF.d_xVals;
    
    cout << "DEF x: ";
    for (size_t var = 0; var != n1; ++var)
      cout << x[var] << ' ';  
    cout << '\n'; 
    
    cout <<  "cx + Q(x) = " << problem.evaluate(x) << '\n';
     

    /*
              // solving the LP relaxation through L-shaped, followed by warm-started LBDA
    cout << "**************************************************************************************************************************************************************************\n";
    auto t1 = chrono::high_resolution_clock::now();
    ben.lpSolve();
    auto t2 = chrono::high_resolution_clock::now();
    cout << "L-shaped took " << (chrono::duration_cast<chrono::microseconds>(t2 - t1).count() / 1000000.0) << " seconds\n";
    x = ben.d_xvals;
    for (size_t var = 0; var != n1; ++var)
      cout << x[var] << ' ';  
    cout << "\nL-shaped solution objval: " << problem.evaluate(x) << '\n';
    
  
    cout << "**************************************************************************************************************************************************************************\n";
    double alpha[m2];
    fill_n(alpha, m2, 0.0);
    auto t3 = chrono::high_resolution_clock::now();
    ben.lbda(alpha, 1.0);
    auto t4 = chrono::high_resolution_clock::now();
    cout << "LBDA took " << (chrono::duration_cast<chrono::microseconds>(t4 - t3).count() / 1000000.0) << " seconds\n";
  
          // printing corresponding solution and objective value
    x = ben.d_xvals;
    for (size_t var = 0; var != n1; ++var)
      cout << x[var] << ' ';  
    cout << "\nLBDA solution objval: " << problem.evaluate(x) << '\n';  
    */